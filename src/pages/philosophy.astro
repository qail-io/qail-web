---
import BaseLayout from "../layouts/BaseLayout.astro";
import ComparisonGrid from "../components/ComparisonGrid.astro";

const qailExample = `Qail::get("users")
  .columns(["id", "email"])
  .filter("active", Eq, true)
  .limit(10)`;

const sqlExample = `SELECT id, email
FROM users
WHERE active = true
LIMIT 10`;

const ormCode = `user.posts().comments().author()
// 3+ hidden queries?`;

const qailCode = `Qail::get("posts")
  .left_join("comments", "post_id", "id")
  .left_join("users", "author_id", "id")`;
---

<BaseLayout
    title="The Manifesto | QAIL"
    description="Why we built QAIL: Skip the string layer. AST to wire protocol bytes. The manifesto behind the vision."
>
    <header class="page-header">
        <div class="container">
            <h1>The Manifesto</h1>
            <p class="subtitle">
                A story about the "Database Dilemma" and why we built QAIL.
            </p>
        </div>
    </header>

    <main class="page-content">
        <div class="container prose">
            <section>
                <h2>The Struggle: "Polyglot Hell"</h2>
                <p>
                    We are polyglot developers. On Monday, we write <strong
                        >Rust</strong
                    >. On Tuesday,
                    <strong>Go</strong>. On Wednesday, we maintain a legacy <strong
                        >PHP</strong
                    > system.
                </p>
                <p>
                    Every time we switch languages, we have to switch our
                    paradigms:
                </p>
                <ul>
                    <li>
                        In <strong>Rust</strong>, we choose between Diesel's
                        strict compile-time types or SQLx's raw flexibility.
                    </li>
                    <li>
                        In <strong>Go</strong>, we balance GORM's convenience
                        with the performance of raw
                        <code>database/sql</code>.
                    </li>
                    <li>
                        In <strong>Node.js</strong>, we rely on Prisma for
                        safety but pay the cost of heavy binary sidecars.
                    </li>
                    <li>
                        In <strong>Python</strong>, we leverage Django's speed
                        of development but hit performance walls at scale.
                    </li>
                    <li>
                        In <strong>PHP</strong>, we love Eloquent's
                        expressiveness but sometimes need lighter, faster query
                        options.
                    </li>
                </ul>
                <p>
                    <strong
                        >The problem isn't the data. The problem is the string
                        layer.</strong
                    > Every ORM generates SQL strings. Every driver parses them again.
                    Why not skip strings entirely?
                </p>
            </section>

            <section>
                <h2>The Origin: "I Don't Want You to Suffer"</h2>
                <blockquote
                    class="manifesto-quote"
                    style="border-left-color: var(--accent-purple); background: rgba(168, 85, 247, 0.05);"
                >
                    "I originally built QAIL for internal use to solve my own
                    polyglot headaches. But I realized that keeping it private
                    meant letting other engineers suffer through the same
                    'Database Dilemma'. I decided to open-source it so we can
                    all skip the string layer."
                </blockquote>
            </section>

            <section>
                <h2>The Realization: "SQL is Assembly"</h2>
                <p>
                    We realized something profound: <strong
                        >SQL is not source code. SQL is Assembly.</strong
                    >
                </p>
                <p>
                    SQL is verbose, powerful, and dangerous. It is the low-level
                    instruction set of the database engine.
                </p>
                <ul>
                    <li>
                        <strong>Raw SQL</strong> offers ultimate control, but maintaining
                        raw strings across a large codebase requires immense discipline.
                    </li>
                    <li>
                        <strong>ORMs</strong> provide fantastic productivity, but
                        the abstraction sometimes comes at the cost of fine-grained
                        performance control.
                    </li>
                </ul>
                <p>
                    We didn't need a compromise. We needed a <strong
                        >Universal AST</strong
                    >.
                </p>
            </section>

            <section>
                <h2>The Savior: QAIL</h2>
                <p>
                    QAIL is the "Universal AST for Databases". It is not a text
                    syntax that compiles to SQL‚Äîit is a native data structure
                    that encodes directly to database wire protocols.
                </p>
                <p>
                    It separates the <strong>Code</strong> (your query AST) from the
                    <strong>Data</strong> (your parameters). It creates a unified
                    structure that works the same way in Rust, Go, Node, and PHP.
                </p>

                <ComparisonGrid
                    leftTitle="Build This (Rust)"
                    leftCode={qailExample}
                    leftVariant="qail"
                    rightTitle="Encodes To (Wire Protocol)"
                    rightCode={sqlExample}
                    rightVariant="sql"
                />

                <p>
                    Now, your team builds with <strong>one AST</strong>. The
                    Rust dev, the Go dev, and the Frontend dev all use the same
                    data structure.
                </p>

                <blockquote class="manifesto-quote">
                    "Safety shouldn't require a prison of boilerplate. We moved
                    validation from the 'String' layer to the 'AST' layer. Code
                    is data. Data is typed. Injection is structurally
                    impossible."
                </blockquote>

                <p>
                    By preventing SQL injection at the <strong>AST level</strong
                    >, QAIL ensures your queries are safe before they even reach
                    the database. Unlike ORMs that generate strings at runtime,
                    QAIL encodes directly to wire protocol bytes‚Äî<strong
                        >no string layer at all</strong
                    >.
                </p>
            </section>

            <section>
                <h2>The Vision: Facts, Meaning, and Time</h2>
                <blockquote
                    class="manifesto-quote"
                    style="border-left-color: var(--primary); background: rgba(99, 102, 241, 0.08); font-size: 1.1rem; text-align: center;"
                >
                    "Postgres stores facts, Qdrant stores meaning, Redis stores
                    time ‚Äî QAIL decides."
                </blockquote>
                <p>
                    Modern applications don't run on a single database. They
                    need
                    <strong>specialized engines</strong> for specialized workloads:
                </p>
                <table style="width: 100%; margin: 1rem 0;">
                    <thead>
                        <tr>
                            <th>Engine</th>
                            <th>Role</th>
                            <th>Examples</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>PostgreSQL</strong></td>
                            <td
                                >Source of truth. ACID transactions. Relational
                                data.</td
                            >
                            <td>Users, orders, inventory</td>
                        </tr>
                        <tr>
                            <td><strong>Qdrant</strong></td>
                            <td
                                >Semantic understanding. Vector embeddings. AI
                                search.</td
                            >
                            <td>Recommendations, similarity, RAG</td>
                        </tr>
                        <tr>
                            <td><strong>Redis</strong></td>
                            <td>Ephemeral state. Caching. TTL-managed data.</td>
                            <td>Sessions, rate limits, queues</td>
                        </tr>
                    </tbody>
                </table>
                <p>
                    QAIL is the <strong>decision layer</strong> that unifies these
                    engines. One AST. Three powerhouses. Facts + Meaning + Time.
                </p>
            </section>

            <section>
                <h2>The Architecture: Native Power</h2>
                <p>
                    QAIL is written in <strong>Pure Rust</strong>. It exposes:
                </p>
                <ul>
                    <li>
                        <strong>A C-API</strong> for Go, Python, and Java (via FFI).
                    </li>
                    <li>
                        <strong>A WASM Module</strong> for Node.js and Browsers.
                    </li>
                    <li><strong>A Native Crate</strong> for Rust users.</li>
                </ul>
                <p>
                    It runs in-process. It has zero network overhead. It turns
                    your query generation into a simple CPU function call.
                </p>
            </section>

            <hr style="margin: 3rem 0; opacity: 0.1;" />

            <section>
                <h2>The AST Builder API</h2>
                <p>
                    We designed the builder API for <strong
                        >Type Safety and Clarity.</strong
                    > Every method is purposeful. No strings to parse.
                </p>
                <table style="width: 100%; margin: 1rem 0;">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Purpose</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Qail::get()</code></td>
                            <td>SELECT query</td>
                            <td><code>Qail::get("users")</code></td>
                        </tr>
                        <tr>
                            <td><code>.columns()</code></td>
                            <td>Select specific columns</td>
                            <td><code>.columns(["id", "email"])</code></td>
                        </tr>
                        <tr>
                            <td><code>.filter()</code></td>
                            <td>WHERE condition</td>
                            <td><code>.filter("active", Eq, true)</code></td>
                        </tr>
                        <tr>
                            <td><code>.order_by()</code></td>
                            <td>Sort results</td>
                            <td><code>.order_by("created_at", Desc)</code></td>
                        </tr>
                        <tr>
                            <td><code>.limit()</code></td>
                            <td>Pagination</td>
                            <td><code>.limit(10)</code></td>
                        </tr>
                        <tr>
                            <td><code>.left_join()</code></td>
                            <td>Join tables</td>
                            <td
                                ><code
                                    >.left_join("profiles", "users.id",
                                    "profiles.user_id")</code
                                ></td
                            >
                        </tr>
                    </tbody>
                </table>
            </section>

            <section>
                <h2>üõ°Ô∏è Why No Raw Strings?</h2>
                <p>
                    QAIL intentionally does <strong>not</strong> provide a "Raw SQL"
                    escape hatch. This is not a missing feature‚Äîit's a deliberate
                    design choice.
                </p>

                <h3>The Promise</h3>
                <blockquote
                    style="border-left: 4px solid var(--primary); padding-left: 1rem; margin: 1.5rem 0; font-style: italic;"
                >
                    "If it compiles in QAIL, it is a valid, safe protocol
                    packet."
                </blockquote>

                <h3>Soundness by Construction</h3>
                <p>By forcing all queries through the AST, QAIL guarantees:</p>
                <ul>
                    <li>
                        <strong>SQL Injection is Structurally Impossible</strong
                        > ‚Äî Code and data are never mixed. Parameters are always separate
                        from query structure.
                    </li>
                    <li>
                        <strong>Syntax Errors at Construction Time</strong> ‚Äî Invalid
                        query structures fail when building the AST, before ever touching
                        the database.
                    </li>
                    <li>
                        <strong>Global Safety Invariant</strong> ‚Äî Every query that
                        executes was validated at the type level (compiled languages)
                        or construction time (dynamic languages).
                    </li>
                </ul>

                <h3>The Rust vs C++ Analogy</h3>
                <table style="width: 100%; margin: 1rem 0;">
                    <thead>
                        <tr>
                            <th>Approach</th>
                            <th>Philosophy</th>
                            <th>Result</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>C++ (escape hatches)</td>
                            <td
                                >"Here's safe code, but use pointers if you
                                need"</td
                            >
                            <td>People use pointers ‚Üí Bugs happen</td>
                        </tr>
                        <tr>
                            <td><strong>Rust</strong> (no escape)</td>
                            <td>"If it's not safe, you can't write it"</td>
                            <td>People adapt ‚Üí Memory safety guaranteed</td>
                        </tr>
                        <tr>
                            <td>ORM with Raw</td>
                            <td>"Use the builder, or escape to strings"</td>
                            <td>People use Raw ‚Üí Injection possible</td>
                        </tr>
                        <tr>
                            <td><strong>QAIL</strong> (pure AST)</td>
                            <td>"If it's not in the AST, you can't query it"</td
                            >
                            <td>People adapt ‚Üí Injection impossible</td>
                        </tr>
                    </tbody>
                </table>

                <h3>For Those Who Need Raw SQL</h3>
                <p>
                    If you need raw SQL strings, use <code>sqlx</code> or another
                    driver. QAIL is for those who want
                    <strong>guarantees</strong>, not flexibility.
                </p>

                <p
                    style="text-align: center; font-size: 1.25rem; margin-top: 2rem; color: var(--primary);"
                >
                    <em>"QAIL: Sound by Construction."</em>
                </p>
            </section>

            <section>
                <h2>üö´ Why QAIL is NOT an ORM</h2>
                <p>
                    QAIL intentionally does <strong>not</strong> provide type codegen
                    or ORM patterns like relations and lazy loading. This is not a
                    limitation‚Äîit's a <strong
                        >deliberate architectural choice</strong
                    >.
                </p>

                <h3>What QAIL Is</h3>
                <table style="width: 100%; margin: 1rem 0;">
                    <thead>
                        <tr>
                            <th>ORMs (Prisma, Diesel, SeaORM)</th>
                            <th>QAIL</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Object-Relational Mapper</td>
                            <td
                                ><strong>Query Language & Wire Protocol</strong
                                ></td
                            >
                        </tr>
                        <tr>
                            <td>Hide SQL behind objects</td>
                            <td
                                ><strong>Make queries portable & safe</strong
                                ></td
                            >
                        </tr>
                        <tr>
                            <td>Generate structs from schema</td>
                            <td><strong>You define your own structs</strong></td
                            >
                        </tr>
                        <tr>
                            <td>"Don't think about SQL"</td>
                            <td
                                ><strong>"Think in queries, not strings"</strong
                                ></td
                            >
                        </tr>
                    </tbody>
                </table>

                <h3>Why No Type Codegen?</h3>
                <ul>
                    <li>
                        <strong>You already have structs</strong> ‚Äî You define them
                        in your code, not generate them from a schema. This keeps
                        you in control.
                    </li>
                    <li>
                        <strong>Codegen creates coupling</strong> ‚Äî Schema change
                        = regenerate = rebuild everything. QAIL queries work with
                        any struct you provide.
                    </li>
                    <li>
                        <strong>Flexibility</strong> ‚Äî Same query, different structs
                        for different use cases (API response vs internal model).
                    </li>
                </ul>

                <h3>Why No Relations or Lazy Loading?</h3>
                <ul>
                    <li>
                        <strong>N+1 is an anti-pattern</strong> ‚Äî Lazy loading hides
                        performance problems. Explicit JOINs make queries predictable.
                    </li>
                    <li>
                        <strong>Wire protocol focus</strong> ‚Äî QAIL sends bytes to
                        the database, not object graphs. Relations are application
                        logic.
                    </li>
                    <li>
                        <strong>Explicit is better</strong> ‚Äî CTEs + JOINs are clearer
                        than magic <code>.include()</code> methods.
                    </li>
                </ul>

                <ComparisonGrid
                    leftTitle="ORM Way (Hidden Queries)"
                    leftCode={ormCode}
                    leftVariant="qail"
                    rightTitle="QAIL Way (Explicit)"
                    rightCode={qailCode}
                    rightVariant="sql"
                />

                <h3>What QAIL Focuses On</h3>
                <ul>
                    <li>
                        ‚úÖ <strong>Best-in-class query syntax</strong> ‚Äî 3-5x shorter
                        than SQL
                    </li>
                    <li>
                        ‚úÖ <strong>Direct wire protocol encoding</strong> ‚Äî No string
                        layer
                    </li>
                    <li>
                        ‚úÖ <strong
                            >Migration tooling with impact analysis</strong
                        > ‚Äî Unique to QAIL
                    </li>
                    <li>
                        ‚úÖ <strong>Multi-database AST portability</strong> ‚Äî Write
                        once, run anywhere
                    </li>
                </ul>

                <blockquote
                    style="border-left: 4px solid var(--accent-purple); padding-left: 1rem; margin: 1.5rem 0; font-style: italic; background: rgba(168, 85, 247, 0.05);"
                >
                    "QAIL is the query transport layer, not an ORM. If you need
                    relations and codegen, use Prisma or Diesel. If you want the
                    fastest, safest way to talk to your database, use QAIL."
                </blockquote>
            </section>

            <section>
                <h2>üöÄ The Future: QAIL Gateway</h2>
                <p>
                    Today, QAIL is a <strong>query language and driver</strong>.
                    Tomorrow, it will be a <strong>complete data layer</strong> that
                    can replace REST APIs and GraphQL.
                </p>

                <blockquote
                    class="manifesto-quote"
                    style="border-left-color: #22c55e; background: rgba(34, 197, 94, 0.08);"
                >
                    "What if your client could speak QAIL binary directly to
                    your database? No JSON serialization. No REST overhead.
                    Native binary protocol."
                </blockquote>

                <h3>The Vision</h3>
                <table style="width: 100%; margin: 1rem 0;">
                    <thead>
                        <tr>
                            <th>Layer</th>
                            <th>Today</th>
                            <th>Tomorrow</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Client</td>
                            <td>REST JSON / GraphQL</td>
                            <td><strong>QAIL AST (binary)</strong></td>
                        </tr>
                        <tr>
                            <td>Server</td>
                            <td>Your API code</td>
                            <td><strong>QAIL Gateway</strong></td>
                        </tr>
                        <tr>
                            <td>Database</td>
                            <td>PostgreSQL</td>
                            <td>Postgres + Qdrant + Redis</td>
                        </tr>
                    </tbody>
                </table>

                <h3>What Makes It Different</h3>
                <ul>
                    <li>
                        <strong>Binary wire format</strong> ‚Äî Not JSON over HTTP,
                        but QAIL AST binary
                    </li>
                    <li>
                        <strong>Row-level security</strong> ‚Äî Policies defined in
                        schema.qail
                    </li>
                    <li>
                        <strong>~1ms latency</strong> ‚Äî vs ~10ms for REST/GraphQL
                    </li>
                    <li>
                        <strong>Tiny client SDK</strong> ‚Äî ~5KB vs 50KB+ for GraphQL
                    </li>
                </ul>

                <p
                    style="text-align: center; color: var(--text-muted); margin-top: 2rem;"
                >
                    <em
                        >This is the long-term vision. Today, QAIL is
                        production-ready as a query language and driver‚Äîpowering
                        real applications like
                        <a
                            href="https://sailtix.com"
                            style="color: var(--primary);">Sailtix</a
                        >.</em
                    >
                </p>
            </section>
        </div>
    </main>
</BaseLayout>

<style>
    /* Table Styling */
    table {
        width: 100%;
        border-collapse: collapse;
        margin: 1.5rem 0;
        font-size: 0.9em;
        border: 1px solid var(--surface-3);
        border-radius: 8px;
        overflow: hidden;
    }

    th,
    td {
        padding: 0.75rem 1rem;
        text-align: left;
        border: 1px solid var(--surface-3);
    }

    th {
        background-color: var(--surface-2);
        font-weight: 600;
        color: var(--text-primary);
    }

    tr:nth-child(even) {
        background-color: rgba(255, 255, 255, 0.02);
    }

    /* Code Block Styling */
    .code-block {
        background: var(--surface-2);
        border-radius: 8px;
        padding: 1rem;
        border: 1px solid var(--surface-3);
    }

    .code-block code {
        white-space: pre-wrap;
        word-wrap: break-word;
        display: block;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.85rem;
        line-height: 1.5;
    }

    .code-block.qail {
        border-left: 3px solid var(--accent);
    }

    .code-block.sql {
        border-left: 3px solid #3b82f6;
        background: rgba(59, 130, 246, 0.05);
    }

    .code-block small {
        display: block;
        color: var(--text-muted);
        margin-bottom: 0.5rem;
        font-size: 0.75rem;
    }

    /* Comparison Grid */
    .comparison-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        margin: 1.5rem 0;
    }

    @media (max-width: 768px) {
        .comparison-grid {
            grid-template-columns: 1fr;
        }
    }

    /* Prose Styling */
    .prose ul {
        padding-left: 1.5rem;
    }

    .prose li {
        margin: 0.5rem 0;
    }

    .prose code {
        background: var(--surface-3);
        padding: 0.15rem 0.4rem;
        border-radius: 4px;
        font-size: 0.85em;
        font-family: "JetBrains Mono", monospace;
    }
</style>
